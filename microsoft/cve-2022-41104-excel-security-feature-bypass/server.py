#!/usr/bin/python3

import argparse
import socket
import threading
import sys

args = None
port_handlers = []


def print_verbose(message):
  global args
  if args.verbose:
    print(message)


def exit_error(message):
  print(f'ERROR: {message}')
  try:
    for port_handler in port_handlers:
      port_handler.stop()
  except:
    pass
  sys.exit(1)


def handle_data(data):
  try:
    data = data.split('OPTIONS /')[1].split('.xlsx')[0]
    data = data.replace('%7C', ', ')
    data = data.replace('%20', ' ')
    print(data)
  except:
    pass


class PortHandler(threading.Thread):
  """
  Waits for WewbDAV connections on a given port, prints the requested path, and
  closes the connection.
  """
  def __init__(self, address, port):
    threading.Thread.__init__(self)
    self.address = address
    self.port = port
    self.client = None
    self.listen = True

  def stop(self):
    self.listen = False
    try:
      self.client.close()
    except:
      pass
    if self.sock:
      print_verbose(f'Closing port {self.port}')
      self.sock.shutdown(socket.SHUT_RDWR)
      self.sock.close()

  def run(self):
    try:
      self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
      self.sock.bind((self.address, self.port))
      self.sock.listen(5)
    except socket.error as e:
      errno, strerr = e.args
      print(f'Could not bind port ${self.port}: {strerr}')
      exit()
    while self.listen:
      try:
        print_verbose(f'Waiting for data on port {self.port}')
        self.client, remote_address = self.sock.accept()
        print_verbose(f'Connection from {remote_address} on port {self.port}')
      except:
        pass
      try:
        data = self.client.recv(1024)
        data = data.decode('utf-8')
        print_verbose(f'Received: {data}')
        handle_data(data)
        self.client.close()
      except:
        pass


def main():
  global args
  parser = argparse.ArgumentParser()
  parser.add_argument('-sp', '--start-port', dest='start_port', type=int,
    help='First port in port range.')
  parser.add_argument('-np', '--num-ports', dest='num_ports', type=int,
    help='Number of ports to open.')
  parser.add_argument('-a', '--address', dest='address', type=str,
    help='IP address to bind.')
  parser.add_argument('-v', '--verbose', action='store_true',
    help='Be verbose.')
  args = parser.parse_args()

  if not args.address:
    exit_error('Listen address not provided')
  if not args.start_port:
    exit_error('Start port not provided')
  if args.start_port < 1 or args.start_port > 65535:
    exit_error('Invalid start port provided')
  if not args.num_ports:
    exit_error('Number of ports not provided')
  if args.num_ports < 1 or args.start_port + args.num_ports > 65535:
    exit_error('Invalid number of ports provided')

  try:
    for port in range(args.start_port, (args.start_port + args.num_ports)):
      port_handler = PortHandler(args.address, port)
      port_handler.setDaemon(True)
      port_handler.start()
      port_handlers.append(port_handler)
    while True:
      pass
  except KeyboardInterrupt:
    for port_handler in port_handlers:
      port_handler.stop()


if __name__ == '__main__':
    main()
